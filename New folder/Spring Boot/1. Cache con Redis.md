# Cache con redis

## 1. Informaci√≥n general

El cach√© es una t√©cnica de optimizaci√≥n crucial utilizada para mejorar el rendimiento y la escalabilidad de las aplicaciones web. Almacena temporalmente datos en memoria cach√© para reducir el tiempo de acceso y la carga sobre los sistemas backend. Redis (Remote Dictionary Server) es un popular almac√©n de estructuras de datos en memoria, de c√≥digo abierto, usado como cach√©, base de datos y broker de mensajes. En este art√≠culo, te guiaremos sobre c√≥mo integrar el cach√© Redis en una aplicaci√≥n Spring Boot para mejorar su eficiencia y tiempos de respuesta.

### 1.1 Cach√© en Spring Boot con Redis

El cach√© es fundamental para construir aplicaciones de alto rendimiento y escalables. Permite almacenar datos que se acceden frecuentemente en cach√©, reduciendo la necesidad de acceder a sistemas de almacenamiento subyacentes m√°s lentos, como bases de datos. Redis es un popular almac√©n de estructuras de datos en memoria usado como cach√©, base de datos y broker de mensajes. Spring Boot se integra perfectamente con Redis para cach√© a trav√©s de su abstracci√≥n Spring Cache.

### 1.2 Introducci√≥n al Cach√© y Redis

- Cach√©: Consiste en almacenar datos que se acceden con frecuencia en memoria para que futuras solicitudes puedan ser atendidas m√°s r√°pido, sin necesidad de recuperarlos de la fuente primaria (por ejemplo, base de datos o API).

- Redis: Redis es un almac√©n de datos en memoria, de c√≥digo abierto, que soporta varias estructuras de datos como cadenas, hashes, listas, conjuntos y conjuntos ordenados. Redis es muy eficiente y com√∫nmente usado para cach√© por su baja latencia y alto rendimiento.

### 1.3 ¬øPor qu√© usar Redis para cach√© en Spring Boot?

- Rendimiento: Redis opera en memoria, ofreciendo latencia extremadamente baja y acceso a datos a alta velocidad.
- Escalabilidad: Redis maneja un gran n√∫mero de operaciones de lectura/escritura, siendo apto para aplicaciones altamente escalables.
- Flexibilidad: Soporta varios tipos de datos y operaciones, permitiendo escenarios complejos de cach√©.
- Persistencia: Redis puede configurarse para persistir datos en disco, brindando un equilibrio entre velocidad y durabilidad.

### 1.4 Abstracci√≥n Spring Cache

El framework Spring provee una abstracci√≥n de cach√© que permite definir la l√≥gica de cach√© sin ligar la aplicaci√≥n a una soluci√≥n espec√≠fica. Esta abstracci√≥n puede integrarse f√°cilmente con distintos proveedores de cach√©, incluido Redis.

La abstracci√≥n Spring Cache utiliza anotaciones para definir el comportamiento del cach√©:

- @EnableCaching: Habilita la gesti√≥n de cach√© basada en anotaciones de Spring.
- @Cacheable: Indica que el valor retornado por el m√©todo debe ser almacenado en cach√©.
- @CachePut: Actualiza la cach√© sin interferir con la ejecuci√≥n del m√©todo.
- @CacheEvict: Elimina datos del cach√©.

### 1.5 C√≥mo funciona el cach√© con Redis en Spring Boot

- @Cacheable: Cuando se usa, Spring primero verifica si el valor est√° en la cach√© Redis. Si est√° presente, devuelve el valor almacenado sin ejecutar el m√©todo. Si no, ejecuta el m√©todo, almacena el resultado en Redis y devuelve ese resultado.
- @CachePut: Actualiza la cach√© con nuevos datos, independientemente de si el m√©todo se ejecut√≥ o no.
- @CacheEvict: Elimina datos del cach√©, √∫til para mantener la consistencia cuando los datos subyacentes cambian.

## 2. Dependencias

Para comenzar, agreguemos los artefactos spring-boot-starter-cache y spring-boot-starter-data-redis:

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

Estos agregan soporte de cach√© e incorporan todas las dependencias requeridas.

## 3. Configuraci√≥n

Con Spring Boot y la dependencia requerida ya funcionando con Maven, podemos configurar una instancia local de Redis con solo tres l√≠neas en nuestro archivo application.properties como:

```JAVA
# Redis Config
spring.cache.type=redis
spring.redis.host=localhost
spring.redis.port=6379
```

Adem√°s, use la anotaci√≥n @EnableCaching en la clase principal de Spring Boot:

```JAVA
package com.journaldev.rediscachedemo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;

@SpringBootApplication
@EnableCaching
public class Application {

  public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
  }
}
```

Al agregar las dependencias anteriores y la anotaci√≥n @EnableCaching, Spring Boot configurar√° autom√°ticamente un RedisCacheManager con la configuraci√≥n de cach√© predeterminada. Sin embargo, podemos modificar esta configuraci√≥n antes de la inicializaci√≥n del gestor de cach√© de un par de maneras √∫tiles.

Primero, creemos un bean RedisCacheConfiguration:

```JAVA
@Bean
public RedisCacheConfiguration cacheConfiguration() {
    return RedisCacheConfiguration.defaultCacheConfig()
      .entryTtl(Duration.ofMinutes(60))
      .disableCachingNullValues()
      .serializeValuesWith(SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));
}
```

Esto nos da m√°s control sobre la configuraci√≥n predeterminada. Por ejemplo, podemos establecer los valores deseados de tiempo de vida (TTL) y personalizar la estrategia de serializaci√≥n predeterminada para la creaci√≥n de cach√© en vuelo.

Para tener control total sobre la configuraci√≥n de cach√©, registremos nuestro propio bean RedisCacheManagerBuilderCustomizer:

```JAVA
@Bean
public RedisCacheManagerBuilderCustomizer redisCacheManagerBuilderCustomizer() {
    return (builder) -> builder
      .withCacheConfiguration("itemCache",
        RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofMinutes(10)))
      .withCacheConfiguration("customerCache",
        RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofMinutes(5)));
}
```

Aqu√≠ hemos utilizado RedisCacheManagerBuilder junto con RedisCacheConfiguration para configurar valores TTL de 10 y 5 minutos para itemCache y customerCache, respectivamente. Esto ayuda a ajustar a√∫n m√°s el comportamiento de la cach√© por cach√© individual, incluyendo valores nulos, prefijos de claves y serializaci√≥n binaria.

Vale la pena mencionar que los detalles de conexi√≥n predeterminados para la instancia de Redis son localhost:6379. La configuraci√≥n de Redis puede ser utilizada para ajustar a√∫n m√°s los detalles de conexi√≥n de bajo nivel junto con el host y el puerto.

## 4. Ejemplo

### 4.1 Definiendo el Modelo

Para guardar un objeto en la base de datos Redis, definimos un objeto modelo Person con campos b√°sicos:

```JAVA
package com.journaldev.rediscachedemo;

import javax.persistence.*;
import java.io.Serializable;

@Entity
public class User implements Serializable {

    @Id
    private Long id;
    private String name;
    private long followers;

    public User() {
    }

    // constructor, getters y setters est√°ndar
}
```

### 4.2 Definiendo el Repositorio

Antes de mostrar c√≥mo funciona Redis, definiremos un Repositorio para la funcionalidad relacionada con JPA:

```JAVA
package com.journaldev.rediscachedemo;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<User, Long> { }
```

No tiene m√©todos declarados por ahora, ya que no los necesitamos.

### 4.3 Definiendo el Controlador

Los controladores son el lugar donde la cach√© de Redis es llamada a actuar. De hecho, este es el mejor lugar para hacerlo porque la cach√© est√° directamente asociada a √©l, y la solicitud ni siquiera tendr√° que entrar al c√≥digo del servicio para esperar resultados en cach√©. Aqu√≠ est√° el esqueleto del controlador:

```JAVA
package com.journaldev.rediscachedemo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.web.bind.annotation.*;

@RestController
public class UserController {

  private final UserRepository userRepository;

  @Autowired
  public UserController(UserRepository userRepository) {
    this.userRepository = userRepository;
  }
   ...
}
```

Ahora, para poner algo en la cach√©, usamos la anotaci√≥n @Cacheable:

```JAVA
@Cacheable(value = "users", key = "#userId", unless = "#result.followers < 12000")
@RequestMapping(value = "/{userId}", method = RequestMethod.GET)
public User getUser(@PathVariable String userId) {
  LOG.info("Getting user with ID {}.", userId);
  return userRepository.findOne(Long.valueOf(userId));
}
```

En el mapeo anterior, el m√©todo getUser pondr√° una persona en una cach√© llamada ‚Äòusers‚Äô, identificando a esa persona por la clave ‚ÄòuserId‚Äô y solo almacenar√° un usuario con seguidores mayores a 12000. Esto asegura que la cach√© se llene con usuarios que son muy populares y que se consultan con frecuencia. Adem√°s, hemos agregado intencionalmente una l√≠nea de log en la llamada al API.

Hagamos algunas llamadas a la API desde Postman en este momento. Estas son las llamadas que hicimos:

```JAVA
localhost:8090/1
localhost:8090/1
localhost:8090/2
localhost:8090/2
```

Si observamos los logs, ser√°n estos:

```JAVA
... : Getting user with ID 1.
... : Getting user with ID 1.
... : Getting user with ID 2.
```

¬øNot√°s algo? Hicimos cuatro llamadas a la API pero solo hay tres registros en el log. Esto se debe a que el usuario con ID 2 tiene 29000 seguidores y, por lo tanto, sus datos fueron cacheados. Esto significa que cuando se hizo una llamada a la API para ese usuario, los datos se devolvieron desde la cach√© y no se realiz√≥ ninguna consulta a la base de datos.

### 4.4 Actualizando la Cach√©

Los valores de la cach√© tambi√©n deben actualizarse cada vez que se actualizan los valores reales de sus objetos. Esto se puede hacer usando la anotaci√≥n @CachePut:

```JAVA
@CachePut(value = "users", key = "#user.id")
@PutMapping("/update")
public User updatePersonByID(@RequestBody User user) {
  userRepository.save(user);
  return user;
}
```

Con esto, una persona es identificada nuevamente por su ID y se actualiza con los resultados.

### 4.5 Limpiando la Cach√©

Si algunos datos deben eliminarse de la base de datos real, ya no tiene sentido mantenerlos en la cach√©. Podemos limpiar los datos de la cach√© usando la anotaci√≥n @CacheEvict:

```JAVA
@CacheEvict(value = "users", allEntries=true)
@DeleteMapping("/{id}")
public void deleteUserByID(@PathVariable Long id) {
  LOG.info("deleting person with id {}", id);
  userRepository.delete(id);
}
```

En el √∫ltimo mapeo, simplemente eliminamos las entradas de la cach√© y no hicimos nada m√°s.

## 5. Ejemplo 2

### 5.1 Crear una configuraci√≥n opcional de RedisTemplate

Spring Boot autoconfigura RedisTemplate, pero si quer√©s controlar mejor otros aspectos, pod√©s crear tu propio RedisConfig.java:

```JAVA
@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        return new LettuceConnectionFactory();
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10));
        return RedisCacheManager.builder(redisConnectionFactory)
                .cacheDefaults(redisCacheConfiguration)
                .build();
    }
}
```

üëâ ¬øQu√© hace esto?

- @Configuration: Marca la clase como una configuraci√≥n de Spring.

- RedisConnectionFactory: Crea la conexi√≥n entre tu aplicaci√≥n y el servidor de Redis. Usa Lettuce, que es un cliente de Redis r√°pido y no bloqueante.

- CacheManager: Define c√≥mo Spring va a administrar las cach√©s. En este caso, configuraste que cada entrada en Redis dure 10 minutos.

- @EnableCaching: Sin esta anotaci√≥n, aunque configures Redis, nunca se activar√≠an las anotaciones @Cacheable o @CacheEvict. Le dice a Spring que empiece a observar las anotaciones relacionadas al cach√© en todos los servicios.

### 5.2 Usar cach√© en servicios (@Cacheable)

En los m√©todos de PetService, usamos @Cacheable.

Por ejemplo:

```JAVA
@Cacheable(value = "getPublicPets", key = "#speciesList?.toString() + '-' + #age + '-' + #sizeList?.toString() + '-' + #sexList?.toString() + '-' + #pageable.pageNumber")
public Page<PetResponse> getPublicPets(List<String> speciesList,
                                       Integer age,
                                       List<String> sizeList,
                                       List<String> sexList,
                                       Pageable pageable) {
    // l√≥gica del m√©todo...
}
```

üëâ ¬øQu√© hace esto?

- @Cacheable le dice a Spring: "Antes de ejecutar este m√©todo, f√≠jate si ya existe un resultado guardado en Redis con esta llave".

- value = "getPublicPets": Define el nombre del cach√© que va a usar (como una "carpeta" dentro de Redis).

- key = ...: Define c√≥mo armar la clave √∫nica para guardar o buscar en Redis. Combinas filtros como speciesList, age, sizeList, sexList y la p√°gina que se pidi√≥. As√≠ evitas que dos b√∫squedas distintas se pisen entre s√≠.

```JAVA
@Cacheable(value = "getPublicPetById", key = "#id")
public PetResponse getPublicPetById(long id) {
    // l√≥gica del m√©todo...
}
```

üëâ ¬øQu√© hace esto?

- Cachea una mascota individual bas√°ndose en su ID. Si alguien pide el mismo ID, lo devuelve desde Redis, sin tener que ir a la base de datos.

### 5.3 Invalidar (borrar) la cache cuando cambian datos (@CacheEvict)

Cuando alguien crea, actualiza o elimina una mascota, los datos cacheados quedan desactualizados. Ah√≠ es donde entra @CacheEvict, que elimina una entrada (o todo) de Redis cuando ejecut√°s un m√©todo.

```JAVA
@CacheEvict(value = {"getPublicPets"}, allEntries = true)
public Pet createPet(PetRequest petRequest) {
    // C√≥digo para crear la mascota...
}
```

üëâ ¬øQu√© hace esto?

- value = "getPublicPets": Dice qu√© cach√© afectar.

- allEntries = true: Borra todas las entradas del cach√© getPublicPets, porque una nueva mascota podr√≠a afectar cualquier p√°gina o filtro.

```JAVA
@CacheEvict(value = {"getPublicPetById"}, key = "#id")
public Pet updatePet(long id, PetRequest petRequest) {
    // C√≥digo para actualizar la mascota...
}
```

üëâ ¬øQu√© hace esto?

- Solo borra el cach√© de la mascota con ese ID, no todo el cach√© de mascotas.

### 5.4 Actualizar el cache manualmente (@CachePut)

Si quer√©s ser a√∫n m√°s fino, pod√©s actualizar el cach√© en vez de solo borrarlo cuando se actualiza algo.
Para eso existe @CachePut.

```JAVA
@CachePut(value = "getPublicPetById", key = "#id")
public PetResponse updatePet(long id, PetRequest petRequest) {
    // C√≥digo para actualizar la mascota...
}
```

üëâ ¬øQu√© hace esto?

- Ejecuta el m√©todo normal (actualiza DB).

- El resultado se guarda autom√°ticamente en Redis, reemplazando el viejo.

## 6. Resumen

### 6.1 Receta de Caching con Spring-Redis

Para implementar caching en nuestra aplicaci√≥n Spring Boot:

- Configurar el administrador de cach√© de Redis
- Habilitar el caching a nivel de aplicaci√≥n con la anotaci√≥n @EnableCaching

En el archivo principal de la aplicaci√≥n (src/main/java/com/redislabs/edu/redi2read/Redi2readApplication.java), agregar el m√©todo cacheManager como se muestra:

```JAVA
@SpringBootApplication
@EnableCaching
public class Redi2readApplication {

  // ...

  @Bean
  public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() //
        .prefixCacheNameWith(this.getClass().getPackageName() + ".") //
        .entryTtl(Duration.ofHours(1)) //
        .disableCachingNullValues();

    return RedisCacheManager.builder(connectionFactory) //
        .cacheDefaults(config) //
        .build();
  }

  // ...
}
```

El m√©todo cacheManager toma una instancia de RedisConnectionFactory. En √©l, configuraremos nuestra cach√© para usar un prefijo de clave de Redis igual al paquete principal de nuestra aplicaci√≥n m√°s un punto, es decir, com.redislabs.edu.redi2read. Tambi√©n establecemos el TTL o "Tiempo de Vida" de nuestras entradas de cach√© en 1 hora y nos aseguramos de no almacenar valores nulos en cach√©. A nivel de clase, tambi√©n usamos la anotaci√≥n @EnableCaching para habilitar el caching globalmente en nuestras aplicaciones.
Los cambios anteriores requerir√°n las sentencias de importaci√≥n que se muestran a continuaci√≥n:

```JAVA
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import java.time.Duration;
```

### 6.2 Uso de la anotaci√≥n @Cacheable

En el contexto de un servicio RESTful, el caching tiene sentido en el punto de traspaso entre la aplicaci√≥n y el protocolo HTTP. Parece casi tonto pensar en hacer caching en una aplicaci√≥n impulsada por Redis, pero una l√≥gica de negocio compleja que toque muchos repositorios de datos y realice c√°lculos intensivos puede aumentar la latencia de tu respuesta.

El lugar ideal para realizar este caching es a nivel de controlador. Por ejemplo, supongamos que queremos almacenar en cach√© las respuestas de nuestras b√∫squedas de libros en el BookController. Simplemente podr√≠amos agregar la anotaci√≥n @Cacheable de la siguiente manera:

```JAVA
@GetMapping("/search")
@Cacheable("book-search")
public SearchResults<String,String> search(@RequestParam(name="q")String query) {
  RediSearchCommands<String, String> commands = searchConnection.sync();
  SearchResults<String, String> results = commands.search(searchIndexName, query);
  return results;
}
```

Ahora, Spring usar√° Redis para crear claves bajo el prefijo com.redislabs.edu.redi2read.book-search para almacenar las entradas de cach√© del m√©todo search. No hay necesidad de realizar mantenimiento de la cach√© manualmente. Spring interceptar√° la solicitud y verificar√° la cach√©; en caso de un acierto (hit) de cach√©, devolver√° su valor. De lo contrario, en caso de fallo (miss), almacenar√° el valor devuelto por el m√©todo search en la cach√©, permitiendo que el m√©todo se ejecute como si no existiera cach√©.

Si probamos la solicitud http://localhost:8080/api/books/search?q=java:

```JAVA
curl --location --request GET 'http://localhost:8080/api/books/search?q=java'
```

En la primera solicitud obtenemos un tiempo de respuesta de 28 ms:

![](./img/1.1.png)

Las respuestas posteriores se devuelven consistentemente en el rango de 8 ms a 10 ms:

![](./img/1.2.png)